\documentclass[10pt]{article}
\usepackage[ruled,vlined]{algorithm2e}
%\usepackage[margin=1in,footskip=0.25in]{geometry}
\newcommand\mycommfont[1]{\footnotesize\rmfamily{\it #1}}
\SetCommentSty{mycommfont}
\SetKwComment{Comment}{$\triangleright$\ }{}

\begin{document}

Let $G=(V,E)$ be a (uni)directed sequence graph.
Each vertex $v\in V$ is a sequence of length $|v|$.
$v[k]$ is the $k$-th residue on the vertex with $0\le k<|v|$.
To find the optimal alignment between query $P$ and the graph,
classical algorithms compute score $\tilde{H}_{ivk}$,
where $i$ is the positon on $P$ and $k$ is the position on vertex $v$.
In this note, we will use the diagonal formulation: we let $H_{v,s,i-k}=k$ if $\tilde{H}_{ivk}=s$.
Given $H_{vsd}$, the position on the query sequence $i$ equals $d+H_{vsd}$.

Algorithm~\ref{algo:1} computes the optimal alignment score between a query sequnece $P$ and the graph $G$.
The pseudocode probably has the initial condition wrong and it does not consider edge cases,
but the basic idea is there.
The most difficult part to implement the algorithm in its current form is the data structure for $H_{vsd}$.
Dynamically allocating from the heap may be slow.
Perhaps we can manually allocate $H_{vsd}$ from a large memory block.

\begin{algorithm}[!hb]
\DontPrintSemicolon
\footnotesize
\KwIn{Target sequence graph $G=(V,E)$, query sequence $P$ and scoring: $b$ for
mismatch, $q$ for linear gap; $v_0\in V$ and $v_1$ are the start and end
vertices, respectively.}
\KwOut{Best alignment score}
\BlankLine
\textbf{function} {\sc GwfAlign}$(G,P,b,q,r)$
\Begin {
	${\rm push}(D, (v_0,0))$\Comment*[r]{$D$ keeps extensible diagonals}
	$s\gets0$\;
	\While{{\bf true}} {
		$D\gets${\sc GwfExtend}$(H,s,D)$\;
		\If (\Comment*[f]{Finished global alignment}) {$H_{v_1,s,|P|-|v_1|}=|v_1|$} {
			{\bf return} $s$\;
		}
		$s\gets s+1$\;
		{\sc GwfNext}$(H,s,D,b,q)$\;
	}
}
\textbf{function} {\sc GwfExtend}$(H,s,D)$
\Begin {
	$A\gets D$\Comment*[r]{$A$ is the DFS stack}
	$B\gets[]$\Comment*[r]{$B$ will be the new $D$ for the next cycle}
	\While {$|A|\not=0$} {
		$(v,d)\gets{\rm pop}(A)$\;
		$k\gets H_{vsd}$\;
		$i\gets k+d$\;
		\uIf (\Comment*[f]{Linear extension}) {$k<|v|$ {\bf and} $i<|P|$} {
			\While {$i<|P|$ {\bf and} $k<|v|$ {\bf and} $P[i]=v[k]$} {
				$i\gets i+1$\;
				$k\gets k+1$\;
			}
			$H_{vsd}\gets k$\;
			\uIf {$k=|v|$} {
				${\rm push}(A,(v,d))$\;
			} \Else {
				${\rm push}(B,(v,k+1,d-1))$; ${\rm push}(B,(v,k+1,d))$; ${\rm push}(B,(v,k,d+1))$\;
			}
		} \ElseIf (\Comment*[f]{Graph extension}) {$k=|v|$ {\bf and} $i<|P|$} {
			\For (\Comment*[f]{Traverse $v$'s neighbors}) {$(v,w)$ {\bf in} $E$} {
				\uIf {$P[i+1]=w[0]$} {
					${\rm push}(A, (w,i+1))$\;
				} \Else {
					${\rm push}(B, (w,0,i))$; ${\rm push}(B, (w,0,i+1))$; ${\rm push}(B, (w,0,i+2))$\;
				}
			}
		}
	}
	Remove duplicated entries in $B$\Comment*[r]{Could be done by sorting}
	{\bf return} $B$\;
}
\textbf{function} {\sc GwfNext}$(H,s,D,b,q)$
\Begin {
	\For {$(v,k,d)$ {\bf in} $D$} {
		\uIf {$k>0$} {
			$H_{vsd}\gets\max\{H_{v,s-b,d}+1,H_{v,s-q,d-1},H_{v,s-q,d+1}+1\}$\;
		} \Else {
			$i\gets d$\;
			$H_{vsd}\gets H_{v,s-q,d-1}$\Comment*[r]{Insertion to the graph}
			\For {$(u,v)$ {\bf in} $E$} {
				$H_{vsd}\gets\max\{H_{vsd},H_{u,s-b,i-|u|-1},H_{u,s-q,i-|u|}+1\}$\;
			}
		}
	}
}
\caption{Global graph wavefront alignment (GWFA)}\label{algo:1}
\end{algorithm}

\end{document}
